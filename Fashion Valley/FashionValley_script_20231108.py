from sl3 import *
import serial
import utime

""" code below is copied from general_purpose.py """
gp_count = 32  # how many general purpose variable sets there are

def gp_index_valid(gp_index):
    """ returns True if the provided general purpose variable index is valid"""
    if (gp_index >= 1) and (gp_index <= gp_count):
        return True
    else:
        return False
def gp_read_label(gp_index):
    """Returns Label of the general purpose variable.
    :param gp_index: A number between 1 and gp_count
    :type gp_index: int
    :return: the Label of the specified gp
    :rtype: str """
    if gp_index_valid(gp_index):
        return setup_read("GP{} label".format(gp_index))
    else:
        raise ValueError("GP index invalid: ", gp_index)
def gp_find_index(label):
    """ Tells you the index of the general purpose with said label
    Returns zero if no such label is found
    :param label: the customer set label for the gp
    :type label: string
    :return: gp index if a match is found.  zero if no match is found
    :rtype: int """
    for gp_index in range(1, gp_count + 1):
        if label.upper() == gp_read_label(gp_index).upper():
            return gp_index
    return 0  # no gp with that label found
def gp_read_value_by_index(gp_index):
    """ Returns the customer set Value of the general purpose variable.
    :param gp_index: A number between 1 and gp_count
    :type gp_index: int
    :return: the Value of the specified p
    :rtype: float """
    if gp_index_valid(gp_index):
        return float(setup_read("GP{} value".format(gp_index)))
    else:
        raise ValueError("GP index invalid: ", gp_index)
def gp_read_value_by_label(label):
    """ Returns the Value associated with the Label of the general purpose variable.
    :param label: the user set Label of the general purpose variable
    :type label: str
    :return: the Value of the general purpose variable
    :rtype: float  """
    gp_index = gp_find_index(label)
    if gp_index_valid(gp_index):
        # we found a match.  return associated value
        gp_value = "GP{} value".format(gp_index)
        return float(setup_read(gp_value))
    else:
        raise ValueError("GP Label not found: ", label)
        return -999.9  # return this if no match is found
def gp_write_value_by_label(label, value):
    """ Writes a new Value to the general purpose variable associated with the label
    :param label: the user set Label of the general purpose variable
    :type label: str
    :param value: the new Value of the general purpose variable
    :type value: float """
    gp_index = gp_find_index(label)
    if gp_index_valid(gp_index):
        # we found a match.  return associated value
        gp_value = "GP{} value".format(gp_index)
        setup_write(gp_value, value)
    else:
        raise ValueError("GP Label not found: ", label)

def get_pacing_weighting():
    if setup_read("M3 ACTIVE") == "On":
        pacing = "FLOW"
    elif setup_read("M4 ACTIVE") == "On":
        pacing = "TIME"
    else:
        pacing = "NONE"
    return pacing

def get_flow_units():
    # Flow units - cfs or gpm usually
    flow_pacing_data_source = setup_read("M3 META INDEX")
    flow_pacing_data_source_units = setup_read("M"+str(flow_pacing_data_source )+" UNITS")
    if flow_pacing_data_source_units == 'cfs':
        flow_pacing_units = 'cf'
    elif flow_pacing_data_source_units == 'gpm':
        flow_pacing_units = 'gal'
    elif flow_pacing_data_source_units == 'm3s':
        flow_pacing_units = 'm3'
    else:
        pass
    return flow_pacing_data_source_units, flow_pacing_units

def get_time_pacing_increment():
    # Time Pacing Units should be minutes, just need to know how many
    time_pacing_increment = int(setup_read("M4 MEAS INTERVAL").split(":")[1]) #time is formatted '00:01:00'
    return time_pacing_increment


## Pacing Weighting
pacing_weighting = get_pacing_weighting()

## Flow Units
flow_pacing_data_source_units, flow_pacing_units = get_flow_units()

## Time Pacing Increment
time_pacing_increment = get_time_pacing_increment()

# SampleOn - start/stop sampling
sampling_on = False

# Bottle Number (if pacing is changed bottle number will need to update)
bottle_num = float(gp_read_value_by_label("bottle_num"))

# Bottle volume - running total of volume in bottle
vol_in_bottle = 0.0

# We count how many aliquots have been collected in each bottle
aliquots_in_bottle = 0

# Sample pacing - keep a global one to check if there are any changes
#sample_pacing = gp_read_value_by_label("sample_pacing")  # or with Alarm: setup_read("M{} Alarm 1 Threshold".format(index()))
sample_pacing = float(gp_read_value_by_label("sample_pacing")) # SamplePacin is GenPurp variables

# Running total increment (time or volume)
if pacing_weighting == "FLOW":
    g_running_total = 0.0 # start at 0 and count up to pacing
elif pacing_weighting == "TIME":
    g_running_total = sample_pacing # start at time pacing and count down
else:
    g_running_total = sample_pacing

# Time sampler was triggered last.
time_last_sample = 0.0 ## good to know

# Sample log
sample_log = {'SampleEvent':{'IncrTotal':'','Bottle#':'','Aliquot#':'','SampleTime':''}}

## Get pacing
def get_sample_pacing():
    """ Returns the threshold at which the volume/time difference triggers the sampler.
    :return: sample_pacing, bottle_num
    :rtype: float, int """
    ## Get current bottle number and pacing
    global sample_pacing
    global bottle_num
    global aliquots_in_bottle
    global vol_in_bottle
    global flow_pacing_data_source_units
    global flow_pacing_units
    ## Flow units
    flow_pacing_data_source_units, flow_pacing_units = get_flow_units()
    # Check General Purpose Variables (which holds the desired pacing and bottle number) for changes
    # a change in  pacing may or may not also have a bottle change
    pacing_input = float(gp_read_value_by_label("sample_pacing")) # SamplePacin is GenPurp variables
    bottle_input = int(gp_read_value_by_label("bottle_num"))
    # Compare
    print("checking for pacing change...")
    # IF pacing is changed, go to bottle_and_pacing_change
    if sample_pacing != pacing_input:
        sample_pacing, bottle_num  = bottle_and_pacing_change(pacing_input,bottle_input) #returns new bottle number and pacing from change function
    # IF pacing is same, check if bottle num is changed
    else:
        print ("No pacing change...Current pacing: "+ "%.0f"%sample_pacing)
        print("")
        # Check for new bottle but without pacing change (just full bottle)
        # Bottle number is input manually so just use the manual entry
        print("checking for bottle number change...")
        if bottle_num != bottle_input:
            aliquots_in_bottle = 0  # reset aliquot counter to zero
            vol_in_bottle = 0
            print("New Bottle!")
            print("Previous bottle number: " + '%.0f' % bottle_num)
            bottle_num = bottle_input  # update global bottle_num from BottleNum M2 Offset
            print("New bottle number: " + '%.0f' % bottle_input)
            print("................Aliquots in bottle: " + "%.0f" % aliquots_in_bottle)
            print("................Volume in bottle: " + "%.0f" % vol_in_bottle + "mL")
        else:
            print("No bottle change...Current Bottle number: " + '%.0f' % bottle_num)
            print("................Aliquots in bottle: " + "%.0f" % aliquots_in_bottle)
            print("................Volume in bottle: " + "%.0f" % vol_in_bottle + "mL")
            # bottle number should always be whatever is in the GP variable
    return sample_pacing, bottle_num # return new/current pacing volume and new/current bottle number to main function

def bottle_and_pacing_change(pacing_input,bottle_input):
    """ Updates the bottle number (composite) and resets aliquot counts etc
    :return: bottle_num, sample_pacing"""
    global sample_pacing
    global bottle_num
    global aliquots_in_bottle
    global vol_in_bottle
    global flow_pacing_data_source_units
    global flow_pacing_units
    # Update global values
    sample_pacing = float(pacing_input) # update global sample_pacing from GP variable
    bottle_num = bottle_input  # update global bottle_num from BottleNum M2 Offset
    ## Reset aliquot count and volume (may only be dumping out some volume and changing pacing but reset anyway)
    aliquots_in_bottle = 0.
    vol_in_bottle = 0.0
    # Print new parameters
    print("Pacing changed! New Pacing: " + "%.0f"%sample_pacing + flow_pacing_units) # should be updated above
    print("................New Bottle number: "+ "%.0f" % bottle_num) # should be updated above
    print("................Aliquots in bottle: " + "%.0f" %aliquots_in_bottle)
    print("................Volume in bottle: " + "%.0f" % vol_in_bottle +"mL")
    print("")
    # write a log entry
    event_label = " NewPacing: "+"%.0f"%sample_pacing+"  NewBottle: "+ "%.0f" % bottle_num
    reading = Reading(label=event_label, time=utime.time(),etype='E', value=bottle_num,right_digits=0)
    reading.write_log()
    return sample_pacing, bottle_num


def trigger_sampler():
    """ Call to attempt to trigger the sampler.
    Certain conditions may prevent the triggering.
    :return: True if sampler was triggered."""
    global bottle_capacity
    global aliquot_vol_mL
    global aliquots_in_bottle
    global vol_in_bottle
    global time_last_sample
    ## Set trigger to True
    trigger = True

    # DO NOT SAMPLE conditions
    # if aliquots_in_bottle >= bottle_capacity:
    #     trigger = False  # out of capacity - won't overfill bottle
    # elif is_being_tested():
    #     trigger = False  # script is being tested
    # elif setup_read("Recording").upper() == "OFF":
    #     trigger = False  # if recording is off, do not sample

    # If conditions are met, then trigger the sampler
    if trigger == True:
        print ('Sampler Triggered')
        # increment the number of bottles used
        aliquots_in_bottle += 1
        vol_in_bottle = vol_in_bottle + aliquot_vol_mL
        # update the time of the last trigger
        time_last_sample = utime.time()
        # trigger sampler by pulsing output for 0.5 seconds
        power_control('SW1', True)
        utime.sleep(0.5)
        power_control('SW1', False)
        # write a log entry
        t = utime.localtime(time_scheduled())
        day, minute = str(t[2]), str(t[4])
        if len(day) == 1:
            day = '0' + day
        if len(minute) == 1:
            minute = '0' + minute
        sample_time = str(t[1]) + '/' + day + '/' + str(t[0]) + ' ' + str(t[3]) + ':' + minute
        reading = Reading(label="Triggered Sampler", time=time_scheduled(),
                          etype='E', value=aliquots_in_bottle,
                          right_digits=0, quality='G')  # 'E' = event, 'M' = measurement, 'D' = debug
        reading.write_log()
        ## Write display log entries
        global sample_log
        global bottle_num
        global sample_pacing
        pacing_units = setup_read("M1 Units")
        sample_log[sample_time] = {'Pacing': '%.0f' % sample_pacing+pacing_units, 'Bottle#': str(int(bottle_num)),
                                   'Aliquot#': str(int(aliquots_in_bottle)), 'SampleTime': sample_time}
        return True
    # If conditions are NOT met, then DONOT trigger the sampler
    else:
        return False  # Sampler was NOT triggered.

@MEASUREMENT
def HvF_table(stage_in):
    """
    Given stage reading, this script will find the closest stage/discharge pair in
    rating table that is less than the input stage reading, and then perform a linear
    interpolation on the discharge values on either side of the stage reading to
    determine the discharge value at the current stage. For example, a stage value
    of 4" would output 32.0 CFS discharge because 4 is between (3, 22) and (5, 42).

    User will need to define the values for the rating table based on their application.
    The example below assumes an input stage value in inches and outputs discharge in cubic feet
    per second (CFS).

    To configure this script, attach this function to a Stage measurement
    or second meta referring to stage and make sure your stage units match your rating
    table stage values.
    """
    # stage, flow pairs
    STAGETBL = ((01.88,00.01),
(01.89,00.02),
(01.90,00.03),
(01.91,00.04),
(01.92,00.06),
(01.93,00.08),
(01.94,00.10),
(01.95,00.12),
(01.96,00.15),
(01.97,00.18),
(01.98,00.21),
(01.99,00.25),
(02.00,00.28),
(02.01,00.33),
(02.02,00.37),
(02.03,00.42),
(02.04,00.47),
(02.05,00.52),
(02.06,00.57),
(02.07,00.63),
(02.08,00.69),
(02.09,00.76),
(02.10,00.82),
(02.11,00.89),
(02.12,00.97),
(02.13,01.04),
(02.14,01.12),
(02.15,01.20),
(02.16,01.29),
(02.17,01.38),
(02.18,01.47),
(02.19,01.56),
(02.20,01.66),
(02.21,01.76),
(02.22,01.86),
(02.23,01.97),
(02.24,02.08),
(02.25,02.19),
(02.26,02.30),
(02.27,02.42),
(02.28,02.54),
(02.29,02.67),
(02.30,02.80),
(02.31,02.93),
(02.32,03.06),
(02.33,03.20),
(02.34,03.34),
(02.35,03.48),
(02.36,03.63),
(02.37,03.78),
(02.38,03.93),
(02.39,04.09),
(02.40,04.25),
(02.41,04.41),
(02.42,04.57),
(02.43,04.74),
(02.44,04.91),
(02.45,05.09),
(02.46,05.27),
(02.47,05.45),
(02.48,05.63),
(02.49,05.82),
(02.50,06.01),
(02.51,06.20),
(02.52,06.40),
(02.53,06.60),
(02.54,06.80),
(02.55,07.01),
(02.56,07.22),
(02.57,07.43),
(02.58,07.65),
(02.59,07.87),
(02.60,08.09),
(02.61,08.32),
(02.62,08.55),
(02.63,08.78),
(02.64,09.02),
(02.65,09.26),
(02.66,09.50),
(02.67,09.74),
(02.68,09.99),
(02.69,10.24),
(02.70,10.50),
(02.71,10.76),
(02.72,11.02),
(02.73,11.29),
(02.74,11.55),
(02.75,11.83),
(02.76,12.10),
(02.77,12.38),
(02.78,12.66),
(02.79,12.95),
(02.80,13.23),
(02.81,13.52),
(02.82,13.82),
(02.83,14.12),
(02.84,14.42),
(02.85,14.72),
(02.86,15.03),
(02.87,15.34),
(02.88,15.66),
(02.89,15.98),
(02.90,16.30),
(02.91,16.62),
(02.92,16.95),
(02.93,17.28),
(02.94,17.61),
(02.95,17.95),
(02.96,18.29),
(02.97,18.64),
(02.98,18.99),
(02.99,19.34),
(03.00,19.69),
(03.01,20.05),
(03.02,20.41),
(03.03,20.78),
(03.04,21.14),
(03.05,21.51),
(03.06,21.89),
(03.07,22.27),
(03.08,22.65),
(03.09,23.03),
(03.10,23.42),
(03.11,23.81),
(03.12,24.21),
(03.13,24.61),
(03.14,25.01),
(03.15,25.41),
(03.16,25.82),
(03.17,26.23),
(03.18,26.65),
(03.19,27.07),
(03.20,27.49),
(03.21,27.91),
(03.22,28.34),
(03.23,28.77),
(03.24,29.21),
(03.25,29.65),
(03.26,30.09),
(03.27,30.54),
(03.28,30.99),
(03.29,31.44),
(03.30,31.89),
(03.31,32.35),
(03.32,32.82),
(03.33,33.28),
(03.34,33.75),
(03.35,34.22),
(03.36,34.70),
(03.37,35.18),
(03.38,35.66),
(03.39,36.15),
(03.40,36.64),
(03.41,37.13),
(03.42,37.63),
(03.43,38.13),
(03.44,38.63),
(03.45,39.14),
(03.46,39.65),
(03.47,40.17),
(03.48,40.68),
(03.49,41.21),
(03.50,41.73),
(03.51,42.26),
(03.52,42.79),
(03.53,43.32),
(03.54,43.86),
(03.55,44.40),
(03.56,44.95),
(03.57,45.50),
(03.58,46.05),
(03.59,46.60),
(03.60,47.16),
(03.61,47.73),
(03.62,48.29),
(03.63,48.86),
(03.64,49.43),
(03.65,50.01),
(03.66,50.59),
(03.67,51.17),
(03.68,51.76),
(03.69,52.35),
(03.70,52.94),
(03.71,53.54),
(03.72,54.14),
(03.73,54.74),
(03.74,55.35),
(03.75,55.96),
(03.76,56.58),
(03.77,57.20),
(03.78,57.82),
(03.79,58.44),
(03.80,59.07),
(03.81,59.70),
(03.82,60.34),
(03.83,60.98),
(03.84,61.62),
(03.85,62.26),
(03.86,62.91),
(03.87,63.57),
(03.88,64.22),
(03.89,64.88),
(03.90,65.55),
(03.91,66.21),
(03.92,66.88),
(03.93,67.56),
(03.94,68.24),
(03.95,68.92),
(03.96,69.60),
(03.97,70.29),
(03.98,70.98),
(03.99,71.68),
(04.00,72.37),
(04.01,73.08),
(04.02,73.78),
(04.03,74.49),
(04.04,75.20),
(04.05,75.92),
(04.06,76.64),
(04.07,77.36),
(04.08,78.09),
(04.09,78.82),
(04.10,79.55),
(04.11,80.29),
(04.12,81.03),
(04.13,81.78),
(04.14,82.52),
(04.15,83.27),
(04.16,84.03),
(04.17,84.79),
(04.18,85.55),
(04.19,86.32),
(04.20,87.08),
(04.21,87.86),
(04.22,88.63),
(04.23,89.41),
(04.24,90.20),
(04.25,90.98),
(04.26,91.77),
(04.27,92.57),
(04.28,93.37),
(04.29,94.17),
(04.30,94.97),
(04.31,95.78),
(04.32,96.59),
(04.33,97.41),
(04.34,98.23),
(04.35,99.05),
(04.36,99.87),
(04.37,100.70),
(04.38,101.54),
(04.39,102.37),
(04.40,103.21),
(04.41,104.06),
(04.42,104.90),
(04.43,105.76),
(04.44,106.61),
(04.45,107.47),
(04.46,108.33),
(04.47,109.19),
(04.48,110.06),
(04.49,110.94),
(04.50,111.81),
(04.51,112.69),
(04.52,113.57),
(04.53,114.46),
(04.54,115.35),
(04.55,116.25),
(04.56,117.14),
(04.57,118.04),
(04.58,118.95),
(04.59,119.86),
(04.60,120.77),
(04.61,121.68),
(04.62,122.60),
(04.63,123.53),
(04.64,124.45),
(04.65,125.38),
(04.66,126.31),
(04.67,127.25),
(04.68,128.19),
(04.69,129.14),
(04.70,130.08),
(04.71,131.03),
(04.72,131.99),
(04.73,132.95),
(04.74,133.91),
(04.75,134.88),
(04.76,135.85),
(04.77,136.82),
(04.78,137.79),
(04.79,138.77),
(04.80,139.76),
(04.81,140.75),
(04.82,141.74),
(04.83,142.73),
(04.84,143.73),
(04.85,144.73),
(04.86,145.74),
(04.87,146.75),
(04.88,147.76),
(04.89,148.77),
(04.90,149.79),
(04.91,150.82),
(04.92,151.85),
(04.93,152.88),
(04.94,153.91),
(04.95,154.95),
(04.96,155.99),
(04.97,157.04),
(04.98,158.08),
(04.99,159.14),
(05.00,160.19),
(05.01,161.25),
(05.02,162.32),
(05.03,163.38),
(05.04,164.45),
(05.05,165.53),
(05.06,166.61),
(05.07,167.69),
(05.08,168.77),
(05.09,169.86),
(05.10,170.95),
(05.11,172.05),
(05.12,173.15),
(05.13,174.25),
(05.14,175.36),
(05.15,176.47),
(05.16,177.58),
(05.17,178.70),
(05.18,179.82),
(05.19,180.95),
(05.20,182.08),
(05.21,183.21),
(05.22,184.35),
(05.23,185.49),
(05.24,186.63),
(05.25,187.78),
(05.26,188.93),
(05.27,190.08),
(05.28,191.24),
(05.29,192.40),
(05.30,193.57),
(05.31,194.74),
(05.32,195.91),
(05.33,197.09),
(05.34,198.27),
(05.35,199.45),
(05.36,200.64),
(05.37,201.83),
(05.38,203.02),
(05.39,204.22),
(05.40,205.42),
(05.41,206.63),
(05.42,207.84),
(05.43,209.05),
(05.44,210.27),
(05.45,211.49),
(05.46,212.71),
(05.47,213.94),
(05.48,215.17),
(05.49,216.40),
(05.50,217.64),
(05.51,218.89),
(05.52,220.13),
(05.53,221.38),
(05.54,222.63),
(05.55,223.89),
(05.56,225.15),
(05.57,226.42),
(05.58,227.68),
(05.59,228.96),
(05.60,230.23),
(05.61,231.51),
(05.62,232.79),
(05.63,234.08),
(05.64,235.37),
(05.65,236.66),
(05.66,237.96),
(05.67,239.26),
(05.68,240.57),
(05.69,241.87),
(05.70,243.19),
(05.71,244.50),
(05.72,245.82),
(05.73,247.15),
(05.74,248.47),
(05.75,249.80),
(05.76,251.14),
(05.77,252.48),
(05.78,253.82),
(05.79,255.16),
(05.80,256.51),
(05.81,257.86),
(05.82,259.22),
(05.83,260.58),
(05.84,261.94),
(05.85,263.31),
(05.86,264.68),
(05.87,266.06),
(05.88,267.44),
(05.89,268.82),
(05.90,270.21),
(05.91,271.60),
(05.92,272.99),
(05.93,274.39),
(05.94,275.79),
(05.95,277.19),
(05.96,278.60),
(05.97,280.01),
(05.98,281.43),
(05.99,282.85),
(06.00,284.27),
(06.01,285.70),
(06.02,287.13),
(06.03,288.56),
(06.04,290.00),
(06.05,291.44),
(06.06,292.89),
(06.07,294.34),
(06.08,295.79),
(06.09,297.24),
(06.10,298.71),
(06.11,300.17),
(06.12,301.64),
(06.13,303.11),
(06.14,304.58),
(06.15,306.06),
(06.16,307.54),
(06.17,309.03),
(06.18,310.52),
(06.19,312.01),
(06.20,313.51),
(06.21,315.01),
(06.22,316.52),
(06.23,318.03),
(06.24,319.54),
(06.25,321.05),
(06.26,322.57),
(06.27,324.10),
(06.28,325.63),
(06.29,327.16),
(06.30,328.69),
(06.31,330.23),
(06.32,331.77),
(06.33,333.32),
(06.34,334.87),
(06.35,336.42),
(06.36,337.98),
(06.37,339.54),
(06.38,341.10),
(06.39,342.67),
(06.40,344.24),
(06.41,345.82),
(06.42,347.40),
(06.43,348.98),
(06.44,350.57),
(06.45,352.16),
(06.46,353.75),
(06.47,355.35),
(06.48,356.95),
(06.49,358.56),
(06.50,360.17),
(06.51,361.78),
(06.52,363.40),
(06.53,365.02),
(06.54,366.64),
(06.55,368.27),
(06.56,369.90),
(06.57,371.54),
(06.58,373.18),
(06.59,374.82),
(06.60,376.47),
(06.61,378.12),
(06.62,379.77),
(06.63,381.43),
(06.64,383.09),
(06.65,384.76),
(06.66,386.43),
(06.67,388.10),
(06.68,389.78),
(06.69,391.46),
(06.70,393.14),
(06.71,394.83),
(06.72,396.52),
(06.73,398.22),
(06.74,399.92),
(06.75,401.62),
(06.76,403.33),
(06.77,405.04),
(06.78,406.76),
(06.79,408.47),
(06.80,410.20),
(06.81,411.92),
(06.82,413.65),
(06.83,415.38),
(06.84,417.12),
(06.85,418.86),
(06.86,420.61),
(06.87,422.36),
(06.88,424.11),
(06.89,425.86),
(06.90,427.62),
(06.91,429.39),
(06.92,431.15),
(06.93,432.92),
(06.94,434.70),
(06.95,436.48),
(06.96,438.26),
(06.97,440.05),
(06.98,441.84),
(06.99,443.63),
(07.00,445.43),
(07.01,447.23),
(07.02,449.03),
(07.03,450.84),
(07.04,452.65),
(07.05,454.47),
(07.06,456.29),
(07.07,458.11),
(07.08,459.94),
(07.09,461.77),
(07.10,463.61),
(07.11,465.45),
(07.12,467.29),
(07.13,469.14),
(07.14,470.99),
(07.15,472.84),
(07.16,474.70),
(07.17,476.56),
(07.18,478.43),
(07.19,480.29),
(07.20,482.17),
(07.21,484.04),
(07.22,485.92),
(07.23,487.81),
(07.24,489.70),
(07.25,491.59),
(07.26,493.48),
(07.27,495.38),
(07.28,497.29),
(07.29,499.19),
(07.30,501.11),
(07.31,503.02),
(07.32,504.94),
(07.33,506.86),
(07.34,508.79),
(07.35,510.72),
(07.36,512.65),
(07.37,514.59),
(07.38,516.53),
(07.39,518.47),
(07.40,520.42),
(07.41,522.37),
(07.42,524.33),
(07.43,526.29),
(07.44,528.26),
(07.45,530.22),
(07.46,532.19),
(07.47,534.17),
(07.48,536.15),
(07.49,538.13),
(07.50,540.12),
(07.51,542.11),
(07.52,544.10),
(07.53,546.10),
(07.54,548.10),
(07.55,550.11),
(07.56,552.12),
(07.57,554.13),
(07.58,556.15),
(07.59,558.17),
(07.60,560.20),
(07.61,562.22),
(07.62,564.26),
(07.63,566.29),
(07.64,568.33),
(07.65,570.38),
(07.66,572.42),
(07.67,574.48),
(07.68,576.53),
(07.69,578.59),
(07.70,580.65),
(07.71,582.72),
(07.72,584.79),
(07.73,586.86),
(07.74,588.94),
(07.75,591.03),
(07.76,593.11),
(07.77,595.20),
(07.78,597.29),
(07.79,599.39),
(07.80,601.49),
(07.81,603.60),
(07.82,605.71),
(07.83,607.82),
(07.84,609.93),
(07.85,612.05),
(07.86,614.18),
(07.87,616.31),
(07.88,618.44),
(07.89,620.57),
(07.90,622.71),
(07.91,624.86),
(07.92,627.00),
(07.93,629.15),
(07.94,631.31),
(07.95,633.47),
(07.96,635.63),
(07.97,637.80),
(07.98,639.96),
(07.99,642.14),
(08.00,644.32),
(08.01,646.50),
(08.02,648.68),
(08.03,650.87),
(08.04,653.06),
(08.05,655.26),
(08.06,657.46),
(08.07,659.67),
(08.08,661.87),
(08.09,664.09),
(08.10,666.30),
(08.11,668.52),
(08.12,670.75),
(08.13,672.97),
(08.14,675.20),
(08.15,677.44),
(08.16,679.68),
(08.17,681.92),
(08.18,684.17),
(08.19,686.42),
(08.20,688.67),
(08.21,690.93),
(08.22,693.19),
(08.23,695.46),
(08.24,697.73),
(08.25,700.00),
(08.26,702.55),
(08.27,705.10),
(08.28,707.66),
(08.29,710.23),
(08.30,712.80),
(08.31,715.38),
(08.32,717.97),
(08.33,720.56),
(08.34,723.15),
(08.35,725.76),
(08.36,728.37),
(08.37,730.98),
(08.38,733.60),
(08.39,736.23),
(08.40,738.87),
(08.41,741.51),
(08.42,744.15),
(08.43,746.81),
(08.44,749.46),
(08.45,752.13),
(08.46,754.80),
(08.47,757.48),
(08.48,760.16),
(08.49,762.85),
(08.50,765.55),
(08.51,768.25),
(08.52,770.96),
(08.53,773.67),
(08.54,776.40),
(08.55,779.12),
(08.56,781.86),
(08.57,784.60),
(08.58,787.34),
(08.59,790.10),
(08.60,792.85),
(08.61,795.62),
(08.62,798.39),
(08.63,801.17),
(08.64,803.95),
(08.65,806.74),
(08.66,809.54),
(08.67,812.34),
(08.68,815.15),
(08.69,817.97),
(08.70,820.79),
(08.71,823.62),
(08.72,826.46),
(08.73,829.30),
(08.74,832.15),
(08.75,835.00),
(08.76,838.10),
(08.77,841.21),
(08.78,844.33),
(08.79,847.46),
(08.80,850.59),
(08.81,853.74),
(08.82,856.89),
(08.83,860.05),
(08.84,863.21),
(08.85,866.39),
(08.86,869.57),
(08.87,872.76),
(08.88,875.96),
(08.89,879.16),
(08.90,882.38),
(08.91,885.60),
(08.92,888.83),
(08.93,892.07),
(08.94,895.31),
(08.95,898.57),
(08.96,901.83),
(08.97,905.10),
(08.98,908.38),
(08.99,911.67),
(09.00,914.96),
(09.01,918.26),
(09.02,921.58),
(09.03,924.89),
(09.04,928.55),
(09.05,932.21),
(09.06,935.88),
(09.07,939.56),
(09.08,943.25),
(09.09,946.95),
(09.10,950.66),
(09.11,954.38),
(09.12,958.11),
(09.13,961.85),
(09.14,965.60),
(09.15,969.36),
(09.16,973.14),
(09.17,976.92),
(09.18,980.71),
(09.19,984.51),
(09.20,988.32),
(09.21,992.14),
(09.22,995.97),
(09.23,999.81),
(09.24,1004.00),
(09.25,1008.23),
(09.26,1012.46),
(09.27,1016.71),
(09.28,1020.97),
(09.29,1025.24),
(09.30,1029.53),
(09.31,1033.83),
(09.32,1038.14),
(09.33,1042.47),
(09.34,1046.80),
(09.35,1051.15),
(09.36,1055.52),
(09.37,1059.89),
(09.38,1064.28),
(09.39,1068.68),
(09.40,1073.10),
(09.41,1077.53),
(09.42,1081.97),
(09.43,1086.42),
(09.44,1090.89),
(09.45,1095.37),
(09.46,1099.86),
(09.47,1104.36),
(09.48,1108.88),
(09.49,1113.41),
(09.50,1117.96),
(09.51,1122.52),
(09.52,1127.09),
(09.53,1131.67),
(09.54,1136.27),
(09.55,1140.88),
(09.56,1145.51),
(09.57,1150.14),
(09.58,1154.79),
(09.59,1159.46),
(09.60,1164.14),
(09.61,1168.83),
(09.62,1173.53),
(09.63,1178.25),
(09.64,1182.98),
(09.65,1187.73),
(09.66,1192.48),
(09.67,1197.26),
(09.68,1202.04),
(09.69,1207.03),
(09.70,1212.35),
(09.71,1217.68),
(09.72,1223.03),
(09.73,1228.40),
(09.74,1233.79),
(09.75,1239.19),
(09.76,1244.61),
(09.77,1250.05),
(09.78,1255.50),
(09.79,1260.98),
(09.80,1266.47),
(09.81,1271.98),
(09.82,1277.50),
(09.83,1283.05),
(09.84,1288.61),
(09.85,1294.19),
(09.86,1299.78),
(09.87,1305.40),
(09.88,1311.03),
(09.89,1316.68),
(09.90,1322.35),
(09.91,1328.04),
(09.92,1333.74),
(09.93,1339.46),
(09.94,1345.20),
(09.95,1350.96),
(09.96,1356.74),
(09.97,1362.54),
(09.98,1368.35),
(09.99,1374.18),
(10.00,1380.03),
(10.01,1385.90),
(10.02,1391.78),
(10.03,1397.69),
(10.04,1403.61),
(10.05,1409.56),
(10.06,1415.52),
(10.07,1421.49),
(10.08,1427.49),
(10.09,1433.51),
(10.10,1439.54),
(10.11,1445.60),
(10.12,1451.67),
(10.13,1457.76),
(10.14,1463.87),
(10.15,1470.47),
(10.16,1477.19),
(10.17,1483.94),
(10.18,1490.71),
(10.19,1497.50),
(10.20,1504.32),
(10.21,1511.16),
(10.22,1518.03),
(10.23,1524.91),
(10.24,1531.83),
(10.25,1538.76),
(10.26,1545.72),
(10.27,1552.71),
(10.28,1559.71),
(10.29,1566.74),
(10.30,1573.80),
(10.31,1580.88),
(10.32,1587.98),
(10.33,1595.11),
(10.34,1602.26),
(10.35,1609.44),
(10.36,1616.64),
(10.37,1623.87),
(10.38,1631.12),
(10.39,1638.39),
(10.40,1645.69),
(10.41,1653.02),
(10.42,1660.37),
(10.43,1667.74),
(10.44,1675.14),
(10.45,1682.56),
(10.46,1690.01),
(10.47,1697.48),
(10.48,1704.98),
(10.49,1712.50),
(10.50,1720.05),
(10.51,1727.63),
(10.52,1735.23),
(10.53,1742.85),
(10.54,1750.50),
(10.55,1758.18),
(10.56,1765.88),
(10.57,1773.61),
(10.58,1781.36),
(10.59,1789.14),
(10.60,1797.13),
(10.61,1805.72),
(10.62,1814.35),
(10.63,1823.00),
(10.64,1831.69),
(10.65,1840.41),
(10.66,1849.17),
(10.67,1857.95),
(10.68,1866.77),
(10.69,1875.62),
(10.70,1884.51),
(10.71,1893.42),
(10.72,1902.37),
(10.73,1911.36),
(10.74,1920.37),
(10.75,1929.42),
(10.76,1938.51),
(10.77,1947.62),
(10.78,1956.77),
(10.79,1965.95),
(10.80,1975.17),
(10.81,1984.42),
(10.82,1993.70),
(10.83,2003.02),
(10.84,2012.37),
(10.85,2021.76),
(10.86,2031.18),
(10.87,2040.63),
(10.88,2050.12),
(10.89,2059.65),
(10.90,2069.20),
(10.91,2078.80),
(10.92,2088.42),
(10.93,2098.09),
(10.94,2107.78),
(10.95,2117.51),
(10.96,2127.28),
(10.97,2137.08),
(10.98,2146.92),
(10.99,2156.79),
(11.00,2166.70),
(11.01,2176.64),
(11.02,2186.62),
(11.03,2196.64),
(11.04,2206.69),
(11.05,2216.77),
(11.06,2227.58),
(11.07,2238.75),
(11.08,2249.96),
(11.09,2261.22),
(11.10,2272.53),
(11.11,2283.88),
(11.12,2295.27),
(11.13,2306.71),
(11.14,2318.20),
(11.15,2329.73),
(11.16,2341.30),
(11.17,2352.93),
(11.18,2364.60),
(11.19,2376.31),
(11.20,2388.08),
(11.21,2399.89),
(11.22,2411.74),
(11.23,2423.64),
(11.24,2435.59),
(11.25,2447.59),
(11.26,2459.63),
(11.27,2471.72),
(11.28,2483.86),
(11.29,2496.05),
(11.30,2508.28),
(11.31,2520.57),
(11.32,2532.90),
(11.33,2545.28),
(11.34,2557.70),
(11.35,2570.18),
(11.36,2582.70),
(11.37,2595.28),
(11.38,2607.90),
(11.39,2620.57),
(11.40,2633.29),
(11.41,2646.06),
(11.42,2658.88),
(11.43,2671.75),
(11.44,2684.67),
(11.45,2697.64),
(11.46,2710.66),
(11.47,2723.73),
(11.48,2736.85),
(11.49,2750.02),
(11.50,2763.24),
(11.51,2776.65),
(11.52,2791.22),
(11.53,2805.85),
(11.54,2820.54),
(11.55,2835.29),
(11.56,2850.11),
(11.57,2864.99),
(11.58,2879.94),
(11.59,2894.95),
(11.60,2910.02),
(11.61,2923.81),
(11.62,2937.66),
(11.63,2951.56),
(11.64,2965.51),
(11.65,2979.52),
(11.66,2993.58),
(11.67,3007.70),
(11.68,3021.87),
(11.69,3036.09),
(11.70,3050.37),
(11.71,3064.70),
(11.72,3079.09),
(11.73,3093.54),
(11.74,3108.04),
(11.75,3122.59),
(11.76,3137.20),
(11.77,3151.87),
(11.78,3166.59),
(11.79,3181.37),
(11.80,3196.20),
(11.81,3211.10),
(11.82,3226.04),
(11.83,3241.05),
(11.84,3256.11),
(11.85,3271.23),
(11.86,3286.41),
(11.87,3301.64),
(11.88,3316.93),
(11.89,3332.28),
(11.90,3347.69),
(11.91,3363.16),
(11.92,3378.68),
(11.93,3394.26),
(11.94,3409.91),
(11.95,3425.61),
(11.96,3441.37),
(11.97,3457.19),
(11.98,3473.06),
(11.99,3489.00),
(12.00,3505.00),
(12.01,3522.46),
(12.02,3540.00),
(12.03,3557.60),
(12.04,3575.28),
(12.05,3593.04),
(12.06,3610.86),
(12.07,3628.76),
(12.08,3646.73),
(12.09,3664.78),
(12.10,3682.90),
(12.11,3701.10),
(12.12,3719.37),
(12.13,3737.72),
(12.14,3756.14),
(12.15,3774.64),
(12.16,3793.21),
(12.17,3811.86),
(12.18,3830.58),
(12.19,3849.38),
(12.20,3868.26),
(12.21,3887.22),
(12.22,3906.25),
(12.23,3925.36),
(12.24,3944.55),
(12.25,3963.81),
(12.26,3983.16),
(12.27,4002.58),
(12.28,4022.08),
(12.29,4041.66),
(12.30,4061.32),
(12.31,4081.06),
(12.32,4100.88),
(12.33,4120.78),
(12.34,4140.75),
(12.35,4160.81),
(12.36,4180.96),
(12.37,4201.18),
(12.38,4221.48),
(12.39,4241.86),
(12.40,4262.33),
(12.41,4282.88),
(12.42,4303.51),
(12.43,4324.22),
(12.44,4345.02),
(12.45,4365.90),
(12.46,4386.86),
(12.47,4407.91),
(12.48,4429.04),
(12.49,4450.26),
(12.50,4471.56),
(12.51,4492.94),
(12.52,4514.41),
(12.53,4535.96),
(12.54,4557.61),
(12.55,4579.33),
(12.56,4601.14),
(12.57,4623.04),
(12.58,4645.03),
(12.59,4667.10),
(12.60,4689.26),
(12.61,4711.51),
(12.62,4733.84),
(12.63,4756.27),
(12.64,4778.78),
(12.65,4801.38),
(12.66,4824.07),
(12.67,4846.84),
(12.68,4869.71),
(12.69,4892.67),
(12.70,4915.72),
(12.71,4938.85),
(12.72,4962.08),
(12.73,4985.40),
(12.74,5008.81),
(12.75,5032.31),
(12.76,5055.91),
(12.77,5079.59),
(12.78,5103.37),
(12.79,5127.24),
(12.80,5151.20),
(12.81,5175.26),
(12.82,5199.41),
(12.83,5223.65),
(12.84,5247.99),
(12.85,5272.42),
(12.86,5296.95),
(12.87,5321.57),
(12.88,5346.29),
(12.89,5371.10),
(12.90,5396.01),
(12.91,5421.01),
(12.92,5446.11),
(12.93,5471.31),
(12.94,5496.60),
(12.95,5521.99),
(12.96,5547.48),
(12.97,5573.07),
(12.98,5598.75),
(12.99,5624.53),
(13.00,5650.42),
(13.01,5676.40),
(13.02,5702.48),
(13.03,5728.66),
(13.04,5754.94),
(13.05,5781.32),
(13.06,5807.80),
(13.07,5834.38),
(13.08,5861.06),
(13.09,5887.85),
(13.10,5914.73),
(13.11,5941.72),
(13.12,5968.81),
(13.13,5996.00),
(13.14,6023.30),
(13.15,6050.70),
(13.16,6078.20),
(13.17,6105.81),
(13.18,6133.52),
(13.19,6161.34),
(13.20,6189.26),
(13.21,6217.29),
(13.22,6245.42),
(13.23,6273.66),
(13.24,6302.00),
(13.25,6330.45),
(13.26,6359.01),
(13.27,6387.67),
(13.28,6416.45),
(13.29,6445.32),
(13.30,6474.31),
(13.31,6503.41),
(13.32,6532.61),
(13.33,6561.93),
(13.34,6591.35),
(13.35,6620.89),
(13.36,6650.53),
(13.37,6680.28),
(13.38,6710.15),
(13.39,6740.12),
(13.40,6770.21),
(13.41,6800.41),
(13.42,6830.72),
(13.43,6861.14),
(13.44,6891.68),
(13.45,6922.33),
(13.46,6953.09),
(13.47,6983.97),
(13.48,7014.96),
(13.49,7046.06),
(13.50,7077.28),
(13.51,7108.61),
(13.52,7140.06),
(13.53,7171.63),
(13.54,7203.31),
(13.55,7235.11),
(13.56,7267.02),
(13.57,7299.05),
(13.58,7331.20),
(13.59,7363.47),
(13.60,7395.85),
(13.61,7428.36),
(13.62,7460.98),
(13.63,7493.72),
(13.64,7526.58),
(13.65,7559.56),
(13.66,7592.66),
(13.67,7625.89),
(13.68,7659.23),
(13.69,7692.69),
(13.70,7726.28),
(13.71,7759.98),
(13.72,7793.81),
(13.73,7827.77),
(13.74,7861.84),
(13.75,7896.04),
(13.76,7930.36),
(13.77,7964.81),
(13.78,7999.38),
(13.79,8034.08),
(13.80,8068.90),
(13.81,8103.84),
(13.82,8138.92),
(13.83,8174.11),
(13.84,8209.44),
(13.85,8244.89),
(13.86,8280.47),
(13.87,8316.18),
(13.88,8352.01),
(13.89,8387.98),
(13.90,8424.07),
(13.91,8460.29),
(13.92,8496.64),
(13.93,8533.12),
(13.94,8569.74),
(13.95,8606.48),
(13.96,8643.35),
(13.97,8680.36),
(13.98,8717.49),
(13.99,8754.76),
(14.00,8792.16),
(14.01,8829.70),
(14.02,8867.36),
(14.03,8905.16),
(14.04,8943.10),
(14.05,8981.17),
(14.06,9019.37),
(14.07,9057.71),
(14.08,9096.19),
(14.09,9134.80),
(14.10,9173.55),
(14.11,9212.43),
(14.12,9251.45),
(14.13,9290.61),
(14.14,9329.90),
(14.15,9369.34),
(14.16,9408.91),
(14.17,9448.62),
(14.18,9488.48),
(14.19,9528.47),
(14.20,9568.60),
(14.21,9608.87),
(14.22,9649.29),
(14.23,9689.84),
(14.24,9730.54),
(14.25,9771.37),
(14.26,9812.36),
(14.27,9853.48),
(14.28,9894.75),
(14.29,9936.16),
(14.30,9977.71),
(14.31,10019.41),
(14.32,10061.26),
(14.33,10103.25),
(14.34,10145.39),
(14.35,10187.67),
(14.36,10230.10),
(14.37,10272.67),
(14.38,10315.40),
(14.39,10358.27),
(14.40,10401.29),
(14.41,10444.45),
(14.42,10487.77),
(14.43,10531.24),
(14.44,10574.85),
(14.45,10618.62),
(14.46,10662.54),
(14.47,10706.60),
(14.48,10750.82),
(14.49,10795.20),
(14.50,10839.72),
(14.51,10884.40),
(14.52,10929.23),
(14.53,10974.21),
(14.54,11019.35),
(14.55,11064.64),
(14.56,11110.09),
(14.57,11155.69),
(14.58,11201.44),
(14.59,11247.36),
(14.60,11293.43),
(14.61,11339.66),
(14.62,11386.04),
(14.63,11432.58),
(14.64,11479.28),
(14.65,11526.14),
(14.66,11573.16),
(14.67,11620.34),
(14.68,11667.68),
(14.69,11715.18),
(14.70,11762.84),
(14.71,11810.66),
(14.72,11858.64),
(14.73,11906.78),
(14.74,11955.09),
(14.75,12003.56),
(14.76,12052.19),
(14.77,12100.99),
(14.78,12149.95),
(14.79,12199.08),
(14.80,12248.37),
(14.81,12297.83),
(14.82,12347.45),
(14.83,12397.24),
(14.84,12447.20),
(14.85,12497.32),
(14.86,12547.62),
(14.87,12598.08),
(14.88,12648.71),
(14.89,12699.51),
(14.90,12750.48),
(14.91,12801.61),
(14.92,12852.92),
(14.93,12904.40),
(14.94,12956.06),
(14.95,13007.88),
(14.96,13059.88),
(14.97,13112.05),
(14.98,13164.39),
(14.99,13216.90),
(15.00,13269.60),
(15.01,13322.46),
(15.02,13375.50),
(15.03,13428.72),
(15.04,13482.11),
(15.05,13535.68),
(15.06,13589.43),
(15.07,13643.35),
(15.08,13697.45),
(15.09,13751.73),
(15.10,13806.19),
(15.11,13860.83),
(15.12,13915.65),
(15.13,13970.64),
(15.14,14025.82),
(15.15,14081.18),
(15.16,14136.73),
(15.17,14192.45),
(15.18,14248.36),
(15.19,14304.45),
(15.20,14360.72),
(15.21,14417.18),
(15.22,14473.83),
(15.23,14530.65),
(15.24,14587.67),
(15.25,14644.87),
(15.26,14702.25),
(15.27,14759.83),
(15.28,14817.59),
(15.29,14875.54),
(15.30,14933.68),
(15.31,14992.00),
(15.32,15050.52),
(15.33,15109.22),
(15.34,15168.12),
(15.35,15227.21),
(15.36,15286.49),
(15.37,15345.96),
(15.38,15405.62),
(15.39,15465.48),
(15.40,15525.53),
(15.41,15585.77),
(15.42,15646.21),
(15.43,15706.84),
(15.44,15767.67),
(15.45,15828.70),
(15.46,15889.92),
(15.47,15951.34),
(15.48,16012.95),
(15.49,16074.77),
(15.50,16136.78),
(15.51,16198.99),
(15.52,16261.40),
(15.53,16324.01),
(15.54,16386.82),
(15.55,16449.83),
(15.56,16513.05),
(15.57,16576.46),
(15.58,16640.08),
(15.59,16703.90),
(15.60,16767.93),
(15.61,16832.16),
(15.62,16896.59),
(15.63,16961.23),
(15.64,17026.07),
(15.65,17091.13),
(15.66,17156.38),
(15.67,17221.85),
(15.68,17287.52),
(15.69,17353.40),
(15.70,17419.49),
(15.71,17485.79),
(15.72,17552.30),
(15.73,17619.02),
(15.74,17685.95),
(15.75,17753.09),
(15.76,17820.45),
(15.77,17888.01),
(15.78,17955.79),
(15.79,18023.79),
(15.80,18092.00),
(15.81,18160.42),
(15.82,18229.06),
(15.83,18297.91),
(15.84,18366.98),
(15.85,18436.27),
(15.86,18505.77),
(15.87,18575.49),
(15.88,18645.43),
(15.89,18715.59),
(15.90,18785.97),
(15.91,18856.57),
(15.92,18927.39),
(15.93,18998.43),
(15.94,19069.70),
(15.95,19141.18),
(15.96,19212.89),
(15.97,19284.82),
(15.98,19356.98),
(15.99,19429.36),
(16.00,19501.96),
(16.01,19574.80),
(16.02,19647.85),
(16.03,19721.14),
(16.04,19794.65),
(16.05,19868.39),
(16.06,19942.36),
(16.07,20016.56),
(16.08,20090.98),
(16.09,20165.64),
(16.10,20240.53),
(16.11,20315.65),
(16.12,20391.00),
(16.13,20466.58),
(16.14,20542.40),
(16.15,20618.45),
(16.16,20694.74),
(16.17,20771.25),
(16.18,20848.01),
(16.19,20925.00),
(16.20,21002.23),
(16.21,21079.69),
(16.22,21157.39),
(16.23,21235.33),
(16.24,21313.51),
(16.25,21391.93),
(16.26,21470.59),
(16.27,21549.49),
(16.28,21628.63),
(16.29,21708.01),
(16.30,21787.64),
(16.31,21867.51),
(16.32,21947.62),
(16.33,22027.97),
(16.34,22108.57),
(16.35,22189.42),
(16.36,22270.51),
(16.37,22351.85),
(16.38,22433.43),
(16.39,22515.27),
(16.40,22597.35),
(16.41,22679.68),
(16.42,22762.26),
(16.43,22845.09),
(16.44,22928.17),
(16.45,23011.50),
(16.46,23095.08),
(16.47,23178.92),
(16.48,23263.01),
(16.49,23347.35),
(16.50,23431.95),
(16.51,23516.80),
(16.52,23601.91),
(16.53,23687.27),
(16.54,23772.89),
(16.55,23858.77),
(16.56,23944.91),
(16.57,24031.30),
(16.58,24117.96),
(16.59,24204.87),
(16.60,24292.05),
(16.61,24379.48),
(16.62,24467.18),
(16.63,24555.14),
(16.64,24643.37),
(16.65,24731.85),
(16.66,24820.61),
(16.67,24909.62),
(16.68,24998.91),
(16.69,25088.45),
(16.70,25178.27),
(16.71,25268.35),
(16.72,25358.70),
(16.73,25449.32),
(16.74,25540.21),
(16.75,25631.37),
(16.76,25722.80),
(16.77,25814.50),
(16.78,25906.47),
(16.79,25998.72),
(16.80,26091.24),
(16.81,26184.03),
(16.82,26277.10),
(16.83,26370.44),
(16.84,26464.06),
(16.85,26557.95),
(16.86,26652.13),
(16.87,26746.58),
(16.88,26841.30),
(16.89,26936.31),
(16.90,27031.60),
(16.91,27127.17),
(16.92,27223.01),
(16.93,27319.14),
(16.94,27415.56),
(16.95,27512.25),
(16.96,27609.23),
(16.97,27706.50),
(16.98,27804.04),
(16.99,27901.88),
(17.00,28000.00))


    # Test for out of bounds stage values
    if stage_in < STAGETBL[0][0]:  # if measured stage is BELOW the FIRST stage value in the FIRST stage,flow pair
        flow = STAGETBL[0][0] # Use lowest flow value in the stage,flow pairs
    elif stage_in > STAGETBL[-1][0]:  # if measured stage is ABOVE the LAST stage value in the LAST stage,flow pair
        flow = STAGETBL[-1][1] # Use last flow value in the stage,flow pairs
    else:
        # use for loop to walk through flow (discharge) table
        for flow_match in range(len(STAGETBL)):
            if stage_in < STAGETBL[flow_match][0]:
                break
        flow_match -= 1  # first pair
        # compute linear interpolation
        a_flow1 = STAGETBL[flow_match][1]
        b_diff_stage = stage_in - STAGETBL[flow_match][0]
        c_stage2 = STAGETBL[flow_match + 1][0]
        d_stage1 = STAGETBL[flow_match][0]
        e_flow2 = STAGETBL[flow_match + 1][1]
        flow = a_flow1 + (b_diff_stage / (c_stage2 - d_stage1)) * (e_flow2 - a_flow1)
    print ("")
    print("Stage: {}".format("%.2f" % stage_in) + ' in')
    print("Flow: {}".format("%.3f"%flow))
    print("")
    return flow

@MEASUREMENT
def AV_PipeFLow_cfs(vel_fps):
    """ Takes velocity as input; meta index should correspond to the velocity measurement.
    returns the flow based on the pipe diameter in the general purpose values
    :param vel_fps:
    :return: flow_gpm or flow_cfs depending on units """

    pipe_diam = gp_read_value_by_label("pipe_diameter_in")
    stage_in = measure("Level_PT", READING_LAST).value
    radius = pipe_diam/2.
    angle = 2. * math.acos((radius - stage_in) / radius)
    area_sq_in = (radius ** 2 * (angle - math.sin(angle))) / 2
    area_sq_ft = area_sq_in * 0.00694444
    flow_cfs = area_sq_ft * vel_fps
    return flow_cfs

@MEASUREMENT
def AV_PipeFLow_gpm(vel_fps):
    """ Takes velocity as input; meta index should correspond to the velocity measurement.
    returns the flow based on the pipe diameter in the general purpose values
    :param vel_fps:
    :return: flow_gpm or flow_cfs depending on units """

    pipe_diam = gp_read_value_by_label("pipe_diameter_in")
    stage_in = measure("Level_PT", READING_LAST).value
    radius = pipe_diam/2.
    angle = 2. * math.acos((radius - stage_in) / radius)
    area_sq_in = (radius ** 2 * (angle - math.sin(angle))) / 2
    area_sq_ft = area_sq_in * 0.00694444
    flow_cfs = area_sq_ft * vel_fps
    flow_gpm = flow_cfs * 448.8325660485
    return flow_gpm


@MEASUREMENT
def flow_weighted_sampling(flow):
    """ This function needs to be associated with the total volume measurement.
    It will compute the total volume based on the current flow rate and past volume.
    The script will trigger the sampler if appropriate.
    :param flow: current flow rate
    :return: the current volume reading"""
    global sampling_on
    global sample_pacing
    global g_running_total
    global bottle_capacity
    global aliquot_vol_mL
    global bottle_num
    global aliquots_in_bottle
    global pacing_weighting
    ## Check if sampling is on
    gp_sampling_on = gp_read_value_by_label("sampling_on") ## Read value in GP
    if gp_sampling_on == 1:
        sampling_on =  True
    elif gp_sampling_on == 0:
        sampling_on = False

    # Aliquot volume
    aliquot_vol_mL = gp_read_value_by_label("aliquot_vol_mL")
    # The container can hold a maximum number of aliquots
    bottle_size_L = gp_read_value_by_label("bottle_size_L")
    # aliquots; 19L / 250mL = 76
    bottle_capacity = bottle_size_L / (aliquot_vol_mL/1000)

    ## Check if program is flow weighted
    pacing_weighting = get_pacing_weighting()
    ## FLow Units
    flow_pacing_data_source_units, flow_pacing_units = get_flow_units()

    if sampling_on == False and  pacing_weighting == "FLOW":
        print ('Sampling is OFF, Sample pacing is FLOW weighted')
        print('Flow:' + "%.2f" % flow + flow_pacing_data_source_units)
        print ("Current bottle number: "+"%.0f"%bottle_num)
        print ("Current pacing: "+"%.0f"%sample_pacing + flow_pacing_units)
        print("Aliquots in bottle: " + "%.0f"%aliquots_in_bottle)
        print("Bottle capacity: " + "%.0f"%bottle_capacity)

    elif sampling_on == True and  pacing_weighting == "FLOW":
        print ('sampling is ON, Sample pacing is FLOW weighted')
        # Measurement is at 1 minute, flow in cfs * 60 sec = cfm
        # flow = measure("Flow_cfs", READING_LAST).value  # what is the current flow rate?
        if flow_pacing_data_source_units == 'cfs' or flow_pacing_data_source_units == 'm3s':
            incremental_vol = flow * 60. # cfs x 60 sec = cf per minute
        elif flow_pacing_data_source_units == 'gpm':
            incremental_vol = flow

        # Add to running total volume
        g_running_total = g_running_total + incremental_vol # cf per minute, at minute intervals just total up

        print('Flow:' + "%.3f" % flow + flow_pacing_data_source_units, '  IncrVol:' + "%.2f" % incremental_vol + flow_pacing_units,
              '  RunningTotalVol:' + "%.2f" % g_running_total + flow_pacing_units)

        # Pacing - check pacing, if it's different this function will update everything
        sample_pacing, bottle_num = get_sample_pacing()

        # if the running total volume is higher than pacing volume, trigger sampler
        if g_running_total >= sample_pacing:
            print('Sample triggered by flow')
            if trigger_sampler():
                # sampler was triggered
                # Write a log entry indicating why sampler was triggered.
                reading = Reading(label="VolumeTrig", time=time_scheduled(),
                                  etype='E', value=g_running_total, quality='G')
                reading.write_log()

                # get remaining volume and keep in running total
                g_running_total = g_running_total - sample_pacing
                ## check to see if sampling is going too fast


        # add diagnostic info to the script status
        print ("Current bottle number: "+"%.0f"%bottle_num)
        print ("Current pacing: "+"%.0f"%sample_pacing)
        print("Aliquots in bottle: " + "%.0f"%aliquots_in_bottle)
        print("Bottle capacity: " + "%.0f"%bottle_capacity)

    if time_last_sample:
        print("Last trigger: {}".format(ascii_time(time_last_sample)))
    else:
        print("Not triggered since bootup")

    # Display log of samples taken
    global sample_log
    print ('Sample Log: ')
    for k in sorted(sample_log):
        print(sample_log[k])
    return g_running_total  # return the total volume (before clearing it)

@MEASUREMENT
def time_weighted_sampling(input):
    """ This function runs a time-weighted sampling program
    The script will trigger the sampler if appropriate.
    :param
    :return: time to next sample"""
    global sampling_on
    global pacing_weighting
    global sample_pacing
    global g_running_total
    global bottle_capacity
    global aliquot_vol_mL
    global bottle_num
    global aliquots_in_bottle
    global vol_in_bottle

    ## Check if sampling is on
    gp_sampling_on = gp_read_value_by_label("sampling_on") ## Read value in GP
    if gp_sampling_on == 1:
        sampling_on =  True
    elif gp_sampling_on == 0:
        sampling_on = False

    # Aliquot volume
    aliquot_vol_mL = gp_read_value_by_label("aliquot_vol_mL")
    # The container can hold a maximum number of aliquots
    bottle_size_L = gp_read_value_by_label("bottle_size_L")
    # aliquots; 19L / 250mL = 76
    bottle_capacity = bottle_size_L / (aliquot_vol_mL/1000)

    ## Check if program is flow weighted
    pacing_weighting = get_pacing_weighting()
    sample_pacing = float(gp_read_value_by_label("sample_pacing")) # SamplePacin is GenPurp variables

    if sampling_on == False and  pacing_weighting == "TIME":
        print ('Sampling is OFF, Sample pacing is TIME weighted')
        print ("Current bottle number: "+"%.0f"%bottle_num)
        print ("Current pacing: "+str(sample_pacing) + "minutes")
        print("Aliquots in bottle: " + "%.0f"%aliquots_in_bottle)
        print("Bottle capacity: " + "%.0f"%bottle_capacity)

    elif sampling_on == True and  pacing_weighting == "TIME":
        print ('sampling is ON, Sample pacing is TIME weighted')
        # Measurement is some # of minutes - time_pacing_increment==meas_interval
        time_pacing_increment = get_time_pacing_increment()

        # Subtract the time_pacing_increment from the total time pacing running_total
        g_running_total = g_running_total - int(time_pacing_increment)  #

        print('  Time Pacing Increment: ' + str(time_pacing_increment) + "minutes",
              '  Time to Next Sample:' + "%.0f" % g_running_total + "minutes")

        # if the running total of minutes is 0 (or less) trigger sampler
        print (type(sample_pacing))
        print(sample_pacing)
        print (type(g_running_total))
        print (g_running_total)
        ## running_total is counting down, when it gets to 0 trigger a sample
        ## and reset running_total to the sample_pacing for the next countdown
        if g_running_total <= 0:
            print ('Countdown timer below sample_pacing')
            if trigger_sampler():
                print ('Sampler triggered by time pacing')
                # sampler was triggered
                # Write a log entry indicating why sampler was triggered.
                reading = Reading(label="TimeTrig", time=time_scheduled(),
                                  etype='E', value=g_running_total, quality='G')
                reading.write_log()

                # reset Time pacing to sample_pacing
                g_running_total = sample_pacing #reset to Sample Pacing eg 30min

        # add diagnostic info to the script status
        print ("Current bottle number: "+"%.0f"%bottle_num)
        print ("Current pacing: "+"%.0f"%sample_pacing)
        print("Aliquots in bottle: " + "%.0f"%aliquots_in_bottle)
        print("Bottle capacity: " + "%.0f"%bottle_capacity)
    else:
        print('sample not triggered yet')

    # Display log of samples taken
    global sample_log
    print ('Sample Log: ')
    for k in sorted(sample_log):
        print(sample_log[k])

    return g_running_total  # return the countdown timer

@MEASUREMENT
def display_sample_pacing(input):
    global sample_pacing
    smaple_pacing = float(gp_read_value_by_label("sample_pacing"))
    print ('Sample Pacing: '+str(sample_pacing))
    return sample_pacing

@MEASUREMENT
def display_bottle_num(input):
    global bottle_num
    bottle_num = float(gp_read_value_by_label("bottle_num"))
    print ('Bottle number: '+str(bottle_num))
    return bottle_num

@MEASUREMENT
def number_of_aliquots(input):
    global aliquots_in_bottle
    print ('Number of aliquots in bottle: '+str(aliquots_in_bottle))
    return aliquots_in_bottle

@MEASUREMENT
def current_program_state(input):
    print(input)
    if input == 0:
        meaning = 'Ready'
    elif input == 1:
        meaning = 'Complete'
    elif input == 2:
        meaning = 'Halted'
    elif input == 3:
        meaning = 'Running'
    else:
        meaning = 'Not sure. didnt work?'
    print ('Current program state: '+meaning)
    return input

@MEASUREMENT
def Next_Bottle_as_int(input):
    """
    Using a SD900 sampler
    only can use over RS232, baud rate is 115200
    RTU mode: # of data bits is 8
    ASCII mode: # of data bits is 7
    parity fixed at none. stop bits is 1 or 2
    """
    
    #modbus_address = 2  # first byte below
    #function_code = 03  # hex for 16-write registers
    message = b'\x02\x03\x00\x49\x00\x02\x15\xEE' # read register 40074 (73 in hex=00 49)

    ## Connect serial and send command
    with serial.Serial("RS232", 115200, stopbits=1) as sampler:
        sampler.port = "RS232"  # i think this is redundant by why not
        sampler.timeout = 1
        sampler.inter_byte_timeout = 0.2  # not sure but going with what was programmed for AV900, maybe something to do with baudrate?
        sampler.delay_before_tx = .5  # if you only get intermittent data, increase this value
        # send command to sampler
        for i in range(3):  # retry 3 times
            print(i, message)
            sampler.write(message)
            buff = sampler.read(8)  # 8 or 16? the response message is 0203020003 + checksum (length=16)
            sampler.flush()  # should add this to command?
            ## if good response from command
            if len(buff) >= 8 and buff[0] == 2 and buff[1]==3 and buff[2]==4:  # our only verification is that first return byte matches modbus address, second byte matches function code, and third byte matches byte count
                print ('buff >=8 and buff[0]==2')
                print(buff)
                print ('Result: Next Bottle is '+str(buff[4]))
                next_bottle = int(buff[4])  

                
            ## if no good response from command, retry
            else:
                print('else')
                print('len(buff)=' + str(len(buff)))
                print(buff)
                utime.sleep(1)

    return next_bottle

@TASK
def turn_on_sampling():
    print("Started sampling!")
    for i in [i for i in range(5,31,1)]:
        setup_write("!M"+str(i)+" meas interval", "00:01:00")
    # Start sampling when level triggered
    gp_write_value_by_label("sampling_on", 1)  # 1=True
    ## Reset all params for start of event
    global sample_pacing
    global g_running_total
    global bottle_num
    global aliquots_in_bottle
    global vol_in_bottle
    ## get pacing
    sample_pacing = float(gp_read_value_by_label("sample_pacing")) # SamplePacin is GenPurp variables

    ## Reset parameters for event
    ## Check if program is flow weighted
    pacing_weighting = get_pacing_weighting()
    # Running total increment (time or volume)
    if pacing_weighting == "FLOW":
        g_running_total = 0.0  # start at 0 and count up to pacing
    if pacing_weighting == "TIME":
        g_running_total = sample_pacing  # start at time pacing and count down
        ## Trigger a sample immediately when sampling is started (only in time-weighted program)
        trigger_sampler()
    bottle_num = float(setup_read("M2 Offset"))
    aliquots_in_bottle = 0
    vol_in_bottle = 0
    return

@TASK
def turn_off_sampling():
    print ("Stopped sampling")
    # Stop sampling when level triggered
    gp_write_value_by_label("sampling_on", 0)  # 0=False
    ## Set data collection back to 5 min
    for i in [i for i in range(5, 14, 1)]:
        setup_write("!M" + str(i) + " meas interval", "00:05:00")
    return

@TASK
def reset_sampling_params():
    print("Manually reset sampling parameters!")

    ## Reset all params for start of event
    global sample_pacing
    global g_running_total
    global bottle_num
    global aliquots_in_bottle
    global vol_in_bottle

    ## get pacing
    sample_pacing = float(gp_read_value_by_label("sample_pacing")) # SamplePacin is GenPurp variables
    bottle_num = int(gp_read_value_by_label("bottle_num"))
    ## Check if program is flow weighted
    pacing_weighting = get_pacing_weighting()
    # Running total increment (time or volume)
    if pacing_weighting == "FLOW":
        g_running_total = 0.0  # start at 0 and count up to pacing
    if pacing_weighting == "TIME":
        g_running_total = sample_pacing  # start at time pacing and count down

    aliquots_in_bottle = 0
    vol_in_bottle = 0
    # Sample log
    sample_log = {'SampleEvent': {'IncrTotal': '', 'Bottle#': '', 'Aliquot#': '', 'SampleTime': ''}}
    return

@TASK
def grab_sample_modbus():
    """
    Using a SD900 sampler
    only can use over RS232, baud rate is 115200
    RTU mode: # of data bits is 8
    ASCII mode: # of data bits is 7
    parity fixed at none. stop bits is 1 or 2
    """
    grab_aok = False
    result_aok = False
    modbus_address = 2 #first byte below
    function_code = 10 #hex for 16-write registers
    grab_sample = b'\x02\x10\x26\xCF\x00\x02\x04\x00\x64\x80\x07\x63\x47' ## 00 64 is hex for 100mL
    #grab_sample = b'\x02\x10\x26\xCF\x00\x02\x04\x00\xFA\x80\x07\xA9\x02' ## 00 FA is hex for 250mL
    grab_sample = b'\x02\x10\x26\xCF\x00\x02\x04\x01\xF4\x80\x07\x62\x96' ## 01 F4 is hex for 500mL
    #grab_sample = b'\x02\x10\x26\xCF\x00\x02\x04\x03\xE8\x80\x07\x63\x47' ## 00 64 is hex for 1000mL
    grab_sample = b'\x02\x10\x26\xCF\x00\x02\x04\x07\xD0\x80\x07\xC2\x17' ## 07 DO is hex for 2000mL
    grab_sample = b'\x02\x10\x26\xCF\x00\x02\x04\x0F\xA0\x80\x07\x21\xAE' ## 07 DO is hex for 4000mL

    with serial.Serial("RS232",115200, stopbits=1) as sampler:
        sampler.port = "RS232" #i think this is redundant by why not
        sampler.timeout = 1
        sampler.inter_byte_timeout = 0.2 #not sure but going with what was programmed for AV900, maybe something to do with baudrate?
        sampler.delay_before_tx = .5  # if you only get intermittent data, increase this value
        max_retries = 3
        retries = 0
        #trigger sampler
        for i in range(max_retries): #retry
            if grab_aok == False or max_retries < retries:
                sampler.write(grab_sample)
                buff = sampler.read(8) # 8 or 16? the response message is 021026CF00027A8C (length=16)
                sampler.flush()
                if len(buff) >= 8 and buff[0] == 2: # our only verification is that first return byte matches modbus address
                    grab_aok = True
                    print('Attempt: '+str(i+1))
                    print ('grab aok')
                    print(buff)
                    print('Length buff: '+str(len(buff)))
                    print ('Buff[0]: '+str(buff[0]))
                    print ('  ')
                    #read result register-does not say if sample was successfully collected, just that command successfully executed
                    utime.sleep(1)
                    result_code_max_retries = 5
                    result_code_tries = 1
                    result_register = b'\x02\x03\x26\xCE\x00\x01\xEE\x8E'
                    for i in range(result_code_max_retries):
                        print ('result code try: '+str(result_code_tries))
                        sampler.write(result_register)
                        buff = sampler.read(8) # 8 or 16? the response message is 021026CF00027A8C (length=16)
                        sampler.flush()
                        if len(buff) >= 7 and buff[0] == 2: # our only verification is that first return byte matches modbus address
                            result_aok = True
                            result_code = buff[3]
                            print (buff)
                            print('Length buff: '+str(len(buff)))
                            print ('buff[0]: '+str(buff[0]))
                            print("result code buff[4]: "+str(buff[4]))
                            print ('  ')
                            if result_code == 2 or result_code ==5 or result_code_tries>result_code_max_retries:
                                break ## stop if code is different than 2 or 5
                            else:
                                pass                           
                        else:
                            print ('unsuccessful read')
                            print (buff)
                        
                        utime.sleep(2)
                        result_code_tries+=1    
                    break
                    
                else:
                    print('Attempt: '+str(i+1))
                    print ('grab NOT aok')
                    print(buff)
                    print('Length buff: '+str(len(buff)))
                    print ('  ')
                    ## WAit 2 sec til retry
                    utime.sleep(2)
                retries+=1
            
    if not grab_aok:
        raise ValueError("Could not trigger sampler")
    if not result_aok:
        raise ValueError("Could not get result")
    return

@TASK
def run_pump_fwd():
    """
    Using a SD900 sampler
    only can use over RS232, baud rate is 115200
    RTU mode: # of data bits is 8
    ASCII mode: # of data bits is 7
    parity fixed at none. stop bits is 1 or 2
    """
    grab_aok = False
    modbus_address = 2 #first byte below
    function_code = 10 #hex for 16-write registers
    pump_on_fwd = b'\x02\x10\x26\xCF\x00\x02\x04\x00\x00\x80\x00\x63\x5A'
    #pump_on_rev = b'\x02\x10\x26\xCF\x00\x02\x04\x00\x01\x80\x00\x32\x9A'
    with serial.Serial("RS232",115200, stopbits=1) as sampler:
        sampler.port = "RS232" #i think this is redundant by why not
        sampler.timeout = 1
        sampler.inter_byte_timeout = 0.2 #not sure but going with what was programmed for AV900, maybe something to do with baudrate?
        sampler.delay_before_tx = .5  # if you only get intermittent data, increase this value
        #trigger sampler
        for i in range(3): #retry
            sampler.write(pump_on_fwd)
            buff = sampler.read(8) # 8 or 16? the response message is 021026CF00027A8C (length=16)
            if len(buff) >= 8 and buff[0] == 2: # our only verification is that first return byte matches modbus address
                print(buff)
                grab_aok = True
                break
            else:
                print(buff)
                utime.sleep(2)  
            
    if not grab_aok:
        raise ValueError("Could not trigger sampler")
    return


@TASK
def run_pump_rev():
    """
    Using a SD900 sampler
    only can use over RS232, baud rate is 115200
    RTU mode: # of data bits is 8
    ASCII mode: # of data bits is 7
    parity fixed at none. stop bits is 1 or 2
    """
    grab_aok = False
    modbus_address = 2  # first byte below
    function_code = 10  # hex for 16-write registers
    #pump_on_fwd = b'\x02\x10\x26\xCF\x00\x02\x04\x00\x00\x80\x00\x63\x5A'
    pump_on_rev = b'\x02\x10\x26\xCF\x00\x02\x04\x00\x01\x80\x00\x32\x9A'
    with serial.Serial("RS232", 115200, stopbits=1) as sampler:
        sampler.port = "RS232"  # i think this is redundant by why not
        sampler.timeout = 1
        sampler.inter_byte_timeout = 0.2  # not sure but going with what was programmed for AV900, maybe something to do with baudrate?
        sampler.delay_before_tx = .5  # if you only get intermittent data, increase this value
        # trigger sampler
        for i in range(3):  # retry
            sampler.write(pump_on_rev)
            buff = sampler.read(8)  # 8 or 16? the response message is 021026CF00027A8C (length=16)
            if len(buff) >= 8 and buff[0] == 2:  # our only verification is that first return byte matches modbus address
                print(buff)
                grab_aok = True
                break
            else:
                print(buff)
                utime.sleep(2)
    if not grab_aok:
        raise ValueError("Could not trigger sampler")
    return

@TASK
def stop_pump():
    """
    Using a SD900 sampler
    only can use over RS232, baud rate is 115200
    RTU mode: # of data bits is 8
    ASCII mode: # of data bits is 7
    parity fixed at none. stop bits is 1 or 2
    """
    grab_aok = False
    modbus_address = 2  # first byte below
    function_code = 10  # hex for 16-write registers
    pump_off = b'\x02\x10\x26\xCF\x00\x02\x04\x00\x00\x80\x01\xA2\x9A'
    with serial.Serial("RS232", 115200, stopbits=1) as sampler:
        sampler.port = "RS232"  # i think this is redundant by why not
        sampler.timeout = 1
        sampler.inter_byte_timeout = 0.2  # not sure but going with what was programmed for AV900, maybe something to do with baudrate?
        sampler.delay_before_tx = .5  # if you only get intermittent data, increase this value

        # trigger sampler
        for i in range(3):  # retry
            sampler.write(pump_off)
            buff = sampler.read(8)  # 8 or 16? the response message is 021026CF00027A8C (length=16)

            if len(buff) >= 8 and buff[
                0] == 2:  # our only verification is that first return byte matches modbus address
                print(buff)
                grab_aok = True
                break
            else:
                print(buff)
                utime.sleep(2)

    if not grab_aok:
        raise ValueError("Could not trigger sampler")
    return


@TASK
def program_Halt():
    """
    Using a SD900 sampler
    only can use over RS232, baud rate is 115200
    RTU mode: # of data bits is 8
    ASCII mode: # of data bits is 7
    parity fixed at none. stop bits is 1 or 2
    """
    grab_aok = False
    modbus_address = 2  # first byte below
    function_code = 10  # hex for 16-write registers
    ## State codes
    #state_code, change_state = 0, b'\x02\x10\x26\xCF\x00\x02\x04\x00\x00\x80\x04\x62\x99' # 0: Ready
    #state_code, change_state = 1, b'\x02\x10\x26\xCF\x00\x02\x04\x00\x01\x80\x04\x33\x59' # 1: Complete -worked
    state_code, change_state = 2, b'\x02\x10\x26\xCF\x00\x02\x04\x00\x02\x80\x04\xC3\x59' # 2: Halted
    #state_code, change_state = 3, b'\x02\x10\x26\xCF\x00\x02\x04\x00\x03\x80\x04\x92\x99' # 3: Restart
    #state_code, change_state = 4, b'\x02\x10\x26\xCF\x00\x02\x04\x00\x04\x80\x04\x23\x58' # 4: Resume
    ## Connect serial and send command
    with serial.Serial("RS232", 115200, stopbits=1) as sampler:
        sampler.port = "RS232"  # i think this is redundant by why not
        sampler.timeout = 1
        sampler.inter_byte_timeout = 0.2  # not sure but going with what was programmed for AV900, maybe something to do with baudrate?
        sampler.delay_before_tx = .5  # if you only get intermittent data, increase this value
        # send command to sampler
        for i in range(3):  # retry 3 times
            print(state_code,change_state)
            sampler.write(change_state)
            buff = sampler.read(8)  # 8 or 16? the response message is 021026CF00027A8C (length=16)
            sampler.flush()  # should add this to command?
            ## if good response from command
            if len(buff) >= 8 and buff[0] == 2:  # our only verification is that first return byte matches modbus address
                command_aok = True
                print ('buff >=8 and buff[0]==2')
                print(buff)

                # if we get the response, then read result register
                utime.sleep(1)
                result_code_max_retries = 5
                result_code_tries = 1
                result_register = b'\x02\x03\x26\xCE\x00\x01\xEE\x8E'
                for i in range(result_code_max_retries):
                    print('result code try: ' + str(result_code_tries))
                    sampler.write(result_register)
                    buff = sampler.read(8)  # 8 or 16? the response message is 021026CF00027A8C (length=16)
                    sampler.flush() #should add this to command?

                    ## if good response from reading result register
                    if len(buff) >= 7 and buff[0] == 2:  # our only verification is that first return byte matches modbus address
                        result_aok = True
                        result_code = buff[4]
                        print(buff)
                        print('Length buff: ' + str(len(buff)))
                        print('buff[0]: ' + str(buff[0]))
                        print("result code buff[4]: " + str(buff[4]))
                        print('  ')
                        if result_code == 0 or result_code == 1 or result_code == 2 or result_code == 3 or result_code_tries > result_code_max_retries:
                            break  ## stop if it gets one of these codes
                        else:
                            pass
                    ## if no good response from reading result register
                    else:
                        utime.sleep(1)
                        result_code_tries += 1
                break
            ## if no good response from command, retry
            else:
                print('else')
                print('len(buff)=' + str(len(buff)))
                print(buff)
                utime.sleep(1)
    if command_aok==False and result_aok==False:
        raise ValueError("Could not change program state")
    return
             
@TASK
def program_Restart():
    """
    Using a SD900 sampler
    only can use over RS232, baud rate is 115200
    RTU mode: # of data bits is 8
    ASCII mode: # of data bits is 7
    parity fixed at none. stop bits is 1 or 2
    """
    grab_aok = False
    modbus_address = 2  # first byte below
    function_code = 10  # hex for 16-write registers
    ## State codes
    #state_code, change_state = 0, b'\x02\x10\x26\xCF\x00\x02\x04\x00\x00\x80\x04\x62\x99' # 0: Ready
    #state_code, change_state = 1, b'\x02\x10\x26\xCF\x00\x02\x04\x00\x01\x80\x04\x33\x59' # 1: Complete -worked
    #state_code, change_state = 2, b'\x02\x10\x26\xCF\x00\x02\x04\x00\x02\x80\x04\xC3\x59' # 2: Halted
    state_code, change_state = 3, b'\x02\x10\x26\xCF\x00\x02\x04\x00\x03\x80\x04\x92\x99' # 3: Restart
    #state_code, change_state = 4, b'\x02\x10\x26\xCF\x00\x02\x04\x00\x04\x80\x04\x23\x58' # 4: Resume
    ## Connect serial and send command
    with serial.Serial("RS232", 115200, stopbits=1) as sampler:
        sampler.port = "RS232"  # i think this is redundant by why not
        sampler.timeout = 1
        sampler.inter_byte_timeout = 0.2  # not sure but going with what was programmed for AV900, maybe something to do with baudrate?
        sampler.delay_before_tx = .5  # if you only get intermittent data, increase this value
        # send command to sampler
        for i in range(3):  # retry 3 times
            print(state_code,change_state)
            sampler.write(change_state)
            buff = sampler.read(8)  # 8 or 16? the response message is 021026CF00027A8C (length=16)
            sampler.flush()  # should add this to command?
            ## if good response from command
            if len(buff) >= 8 and buff[0] == 2:  # our only verification is that first return byte matches modbus address
                command_aok = True
                print ('buff >=8 and buff[0]==2')
                print(buff)

                # if we get the response, then read result register
                utime.sleep(1)
                result_code_max_retries = 5
                result_code_tries = 1
                result_register = b'\x02\x03\x26\xCE\x00\x01\xEE\x8E'
                for i in range(result_code_max_retries):
                    print('result code try: ' + str(result_code_tries))
                    sampler.write(result_register)
                    buff = sampler.read(8)  # 8 or 16? the response message is 021026CF00027A8C (length=16)
                    sampler.flush() #should add this to command?

                    ## if good response from reading result register
                    if len(buff) >= 7 and buff[0] == 2:  # our only verification is that first return byte matches modbus address
                        result_aok = True
                        result_code = buff[4]
                        print(buff)
                        print('Length buff: ' + str(len(buff)))
                        print('buff[0]: ' + str(buff[0]))
                        print("result code buff[4]: " + str(buff[4]))
                        print('  ')
                        if result_code == 0 or result_code == 1 or result_code == 2 or result_code == 3 or result_code_tries > result_code_max_retries:
                            break  ## stop if it gets one of these codes
                        else:
                            pass
                    ## if no good response from reading result register
                    else:
                        utime.sleep(1)
                        result_code_tries += 1
                break
            ## if no good response from command, retry
            else:
                print('else')
                print('len(buff)=' + str(len(buff)))
                print(buff)
                utime.sleep(1)
    if command_aok==False and result_aok==False:
        raise ValueError("Could not change program state")
    return        
        
@TASK
def program_Resume():
    """
    Using a SD900 sampler
    only can use over RS232, baud rate is 115200
    RTU mode: # of data bits is 8
    ASCII mode: # of data bits is 7
    parity fixed at none. stop bits is 1 or 2
    """
    grab_aok = False
    modbus_address = 2  # first byte below
    function_code = 10  # hex for 16-write registers
    ## State codes
    #state_code, change_state = 0, b'\x02\x10\x26\xCF\x00\x02\x04\x00\x00\x80\x04\x62\x99' # 0: Ready
    #state_code, change_state = 1, b'\x02\x10\x26\xCF\x00\x02\x04\x00\x01\x80\x04\x33\x59' # 1: Complete -worked
    #state_code, change_state = 2, b'\x02\x10\x26\xCF\x00\x02\x04\x00\x02\x80\x04\xC3\x59' # 2: Halted
    #state_code, change_state = 3, b'\x02\x10\x26\xCF\x00\x02\x04\x00\x03\x80\x04\x92\x99' # 3: Restart
    state_code, change_state = 4, b'\x02\x10\x26\xCF\x00\x02\x04\x00\x04\x80\x04\x23\x58' # 4: Resume
    ## Connect serial and send command
    with serial.Serial("RS232", 115200, stopbits=1) as sampler:
        sampler.port = "RS232"  # i think this is redundant by why not
        sampler.timeout = 1
        sampler.inter_byte_timeout = 0.2  # not sure but going with what was programmed for AV900, maybe something to do with baudrate?
        sampler.delay_before_tx = .5  # if you only get intermittent data, increase this value
        # send command to sampler
        for i in range(3):  # retry 3 times
            print(state_code,change_state)
            sampler.write(change_state)
            buff = sampler.read(8)  # 8 or 16? the response message is 021026CF00027A8C (length=16)
            sampler.flush()  # should add this to command?
            ## if good response from command
            if len(buff) >= 8 and buff[0] == 2:  # our only verification is that first return byte matches modbus address
                command_aok = True
                print ('buff >=8 and buff[0]==2')
                print(buff)

                # if we get the response, then read result register
                utime.sleep(1)
                result_code_max_retries = 5
                result_code_tries = 1
                result_register = b'\x02\x03\x26\xCE\x00\x01\xEE\x8E'
                for i in range(result_code_max_retries):
                    print('result code try: ' + str(result_code_tries))
                    sampler.write(result_register)
                    buff = sampler.read(8)  # 8 or 16? the response message is 021026CF00027A8C (length=16)
                    sampler.flush() #should add this to command?

                    ## if good response from reading result register
                    if len(buff) >= 7 and buff[0] == 2:  # our only verification is that first return byte matches modbus address
                        result_aok = True
                        result_code = buff[4]
                        print(buff)
                        print('Length buff: ' + str(len(buff)))
                        print('buff[0]: ' + str(buff[0]))
                        print("result code buff[4]: " + str(buff[4]))
                        print('  ')
                        if result_code == 0 or result_code == 1 or result_code == 2 or result_code == 3 or result_code_tries > result_code_max_retries:
                            break  ## stop if it gets one of these codes
                        else:
                            pass
                    ## if no good response from reading result register
                    else:
                        utime.sleep(1)
                        result_code_tries += 1
                break
            ## if no good response from command, retry
            else:
                print('else')
                print('len(buff)=' + str(len(buff)))
                print(buff)
                utime.sleep(1)
    if command_aok==False and result_aok==False:
        raise ValueError("Could not change program state")
    return    
        
@TASK
def Next_Bottle():
    """
    Using a SD900 sampler
    only can use over RS232, baud rate is 115200
    RTU mode: # of data bits is 8
    ASCII mode: # of data bits is 7
    parity fixed at none. stop bits is 1 or 2
    """
    
    #modbus_address = 2  # first byte below
    #function_code = 03  # hex for 16-write registers
    message = b'\x02\x03\x00\x49\x00\x02\x15\xEE' # read register 40074 (73 in hex=00 49)

    ## Connect serial and send command
    with serial.Serial("RS232", 115200, stopbits=1) as sampler:
        sampler.port = "RS232"  # i think this is redundant by why not
        sampler.timeout = 1
        sampler.inter_byte_timeout = 0.2  # not sure but going with what was programmed for AV900, maybe something to do with baudrate?
        sampler.delay_before_tx = .5  # if you only get intermittent data, increase this value
        # send command to sampler
        for i in range(3):  # retry 3 times
            print(i, message)
            sampler.write(message)
            buff = sampler.read(8)  # 8 or 16? the response message is 0203020003 + checksum (length=16)
            sampler.flush()  # should add this to command?
            ## if good response from command
            if len(buff) >= 8 and buff[0] == 2 and buff[1]==3 and buff[2]==4:  # our only verification is that first return byte matches modbus address, second byte matches function code, and third byte matches byte count
                print ('buff >=8 and buff[0]==2')
                print(buff)
                print ('Result: Next Bottle is '+str(buff[4]))
                next_bottle = int(buff[4])
                
            ## if no good response from command, retry
            else:
                print('else')
                print('len(buff)=' + str(len(buff)))
                print(buff)
                utime.sleep(1)

    return next_bottle
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        